<!DOCTYPE html>
<html
  lang="en-us"
  style="background-color: beige; display: initial"
  data-message="Welcome to the site!"
>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>187 - get the DOMRect of a pseudo-element</title>
    <!-- PEDAC

      Objective
      =========
      Determine the viewport position of a border box generated by a generated content pseudo-element.
      In other words, Element.getBoundingClientRect for pseudo-elements.

      UNDERSTANDING THE PROBLEM
      =========================

      - The only thing about pseudo-elements exposed in DOM APIs is their computed styles.
      - this gives us a width and a height
      - but no position

      Hypothesis #1
      - use an Element with the exact same styles at the exact same position in the DOM tree, and read the position of that element
      - not sure if having an element like that wouldn’t affect selector matching, though
      - it would, actually, for exaple with div:nth-child(4)

      Hypothesis #2
      - still replace the pseudo-element with an Element
      - to avoid mismatched CSS selectors, store the computed styles
        of every relevant element, do the replacement, then use those computed
        styles instead of cascading styles
      - a relevant element is any element whose layout styles might change
        when the pseudo-element is replaced with a real Element
      - a change in the tree structure can only affect selector matching among
        the children of the element from which the pseudo-element originates

      Problems with copying used values
      - when you back up the declarations from getComputedStyle and the element
        does generate a box and thus is laid out, then the resolved values
        for layout-depended properties like width will be the used values
      - this means that the initial layout was done on a computed value of
        width: auto, and maybe something like flex-basis: content
      - but when we apply our backed up styles, we may then apply used values
        like width: 190px !important, and that will lead to a different layout
        than the original width: auto layout
      - to get the exact same layout, you’d need to apply the exact same styles
      - the spec for getComputedStyle says the resolved value will be the
        actual computed value if the resolved value of the display property
        is none
      - I’m not sure if it would work correctly, or what would be the impact
        on performance if I set all of the affected elements to display: none
        before backing up their computed styles...
        https://drafts.csswg.org/cssom/#resolved-value
      - even if you grab computed values, the display property value affects
        the values of other properties, which can affect the layout
        - for example, a child of an ancestor with display: none seems to have
          a resolved display: none, too
        - thus, it doesn’t participate in a formatting context it would be
          in if display was not none
        - specifically, min-width will compute to 0px or auto depending on the
          formatting context
        - "It also resolves to zero when no box is generated."
          https://drafts.csswg.org/css-sizing/#valdef-width-auto

      Hypothesis #3
      - elements whose styles we must back up:
        - all descendants of the originating element of the pseudo-element
        - this includes the pseudo-elements of those descendants
      - back up all properties that can affect the geometry of boxes
        - treat this as an optimization
        - start by backing up all properties
      - ensure you get computed values, not used values, for width, height,
        margin, padding, inset
        - getComputedStyle returns resolved values
        - the resolved value of display must be "none" or "contents", then
          you’ll get computed (pre-layout), not used (post-layout), values
      - for other properties, ensure you read resolved values without changing
        the element’s formatting context
        - for example, min-width computes to auto for flex items, but to 0 for
          elements in flow layout

      What works, what doesn’t work
      - hardcoded for ::before
      - doesn’t read the DOMRect
      - doesn’t reset back to the original state
        - as in, we replace the pseudo element with an impostor and it stays
      - only works with a single <string> literal as content value
      - custom CSS properties compute to <string> literals, which is good
      - doesn’t work with attr() content, though
      - doesn’t work with <image> content, quotes, etc.

      Problems
      - content: attr(data-message) computes to attr(data-message)
        - so the impostor element pretending to be the pseudo element
          can’t get the content it needs
      - unclear what impact custom properties may have on this...

      Hypothesis #4
      - create an impostor element as outlined in Hypothesis #3
      - but instead of interpreting the content property and recreating child nodes,
        use a pseudo-element originating from the impostor?
      - the impostor would have to act like the pseudo-element to the outside
        world
      - but the pseudo-element would have to take up the entire size of the impostor?
        - the external world may be dependent on the internal layout of the impostor
        - so this may not be doable if we change the depth of that tree part
      - would it be easier to interpret content and create the right nodes then?


      EXAMPLES / TEST CASES
      =====================


      DATA STRUCTURES
      ===============


      ALGORITHM
      =========


      CODE WITH INTENT
      ================

    -->
    <style>
      :root {
        /* display: none; */
      }

      :root::before {
        --message: 'Welcome!';
        content: 'Welcome!';
        /* content: var(--message); */
        /* content: attr(data-message); */
      }

      * {
        border: 1px dashed black;
      }

      body {
        display: flex;
        /* color: red; */
      }

      body::before {
        content: 'body::before';
        font-size: 3em;
        background-color: royalblue;
        color: white;
        align-self: flex-start;
      }

      body > *:nth-child(4) {
        background-color: tomato;
      }

      h1 {
        margin-left: auto;
      }

      h1::before {
        content: 'H1' !important;
      }

      /* ::after {
        content: '::after';
      } */

      .fake-after {
        font-size: 3em;
      }
    </style>
  </head>
  <body>
    <h1>Text inside an h1 element</h1>
    <p>Text inside a p element</p>
    Text inside a text run
    <script>
      function getRandomInt(max) {
        return Math.floor(Math.random() * max);
      }

      function copyDeclarationBlock(declarationBlock) {
        const result = {};
        for (let i = 0; i < declarationBlock.length; i += 1) {
          const propName = declarationBlock.item(i);
          const propValue = declarationBlock.getPropertyValue(propName);
          result[propName] = propValue;
        }

        return result;
      }

      function backupResolvedStyles(el) {
        for (let i = 0; i < el.children.length; i += 1) {
          const childEl = el.children[i];
          backupResolvedStyles(childEl);
        }

        const backupStyles = {
          id: String(getRandomInt(100000)),
          before: copyDeclarationBlock(getComputedStyle(el, '::before')),
          own: copyDeclarationBlock(getComputedStyle(el)),
          after: copyDeclarationBlock(getComputedStyle(el, '::after')),
        };

        el.backupStyles = backupStyles;
        el.setAttribute('data-id', backupStyles.id);
      }

      const computedPropertyNames = [
        'width',
        'height',
        'margin-top',
        'margin-bottom',
        'margin-left',
        'margin-right',
        'padding-top',
        'padding-bottom',
        'padding-left',
        'padding-right',
        'top',
        'bottom',
        'left',
        'right',
      ];

      function backupComputedStyles(el) {
        for (let i = 0; i < el.children.length; i += 1) {
          const childEl = el.children[i];
          backupComputedStyles(childEl);
        }

        const declarationBlocks = {
          before: getComputedStyle(el, '::before'),
          own: getComputedStyle(el),
          after: getComputedStyle(el, '::after'),
        };
        computedPropertyNames.forEach((propName) => {
          Object.entries(declarationBlocks).forEach(([type, block]) => {
            const value = block.getPropertyValue(propName);
            el.backupStyles[type][propName] = value;
          });
        });
      }

      function backupStyles(el) {
        backupResolvedStyles(el);
        const inlineStyleCSSTextBackup = document.documentElement.style.cssText;
        document.documentElement.style.setProperty(
          'display',
          'none',
          'important'
        );

        backupComputedStyles(el);

        document.documentElement.style.cssText = inlineStyleCSSTextBackup;
      }

      function applyBackupStyles(el) {
        const rulesString = recursivelyBuildBackupStylesString(el);
        const styleEl = document.createElement('style');
        styleEl.id = 'style-snapshot';
        styleEl.textContent = rulesString;
        document.body.append(styleEl);
      }

      function recursivelyBuildBackupStylesString(el) {
        const elRulesString = buildBackupStylesRulesString(el);
        const childElRulesStrings = [];
        for (let i = 0; i < el.children.length; i += 1) {
          const childEl = el.children[i];
          childElRulesStrings.push(recursivelyBuildBackupStylesString(childEl));
        }

        return [elRulesString, childElRulesStrings.join('\n')].join('\n');
      }

      function buildDeclarationString(backupStyles) {
        return Object.entries(backupStyles)
          .map(([name, value]) => `${name}: ${value} !important;`)
          .join('\n');
      }

      function buildBackupStylesRulesString(el) {
        const id = el.backupStyles.id;
        const declarationStrings = {
          before: buildDeclarationString(el.backupStyles.before),
          own: buildDeclarationString(el.backupStyles.own),
          after: buildDeclarationString(el.backupStyles.after),
        };
        const rulesString = `
          [data-id="${id}"]::before {
            ${declarationStrings.before}
          }

          [data-id="${id}-before"] {
            ${declarationStrings.before}
          }

          [data-id="${id}"] {
            ${declarationStrings.own}
          }

          [data-id="${id}"]::after {
            ${declarationStrings.after}
          }

          [data-id="${id}-after"] {
            ${declarationStrings.after}
          }
        `;

        return rulesString;
      }

      function getBoundingClientRectPseudoEl(el, pseudoElName) {
        backupStyles(el);
        applyBackupStyles(el);
        inhibitPseudoElementCreation(el);
        const impostorEl = document.createElement('div');
        const attrValue = `${el.backupStyles.id}-${pseudoElName}`;
        const contentValue = el.backupStyles[pseudoElName]['content'];
        const contentValueStrippedQuoteMarks = contentValue.slice(1, -1);
        impostorEl.textContent = contentValueStrippedQuoteMarks;
        impostorEl.setAttribute('data-id', attrValue);

        if (pseudoElName === 'before') {
          el.prepend(impostorEl);
        } else if (pseudoElName === 'after') {
          el.append(impostorEl);
        }

        const impostorDOMRect = impostorEl.getBoundingClientRect();
        document.getElementById('style-snapshot').remove();
        document.getElementById('pseudo-element-inhibitor').remove();
        impostorEl.remove();
        return impostorDOMRect;
      }

      function inhibitPseudoElementCreation(el) {
        const uniqueID = 'some-unique-id';
        const styleEl = document.createElement('style');
        el.classList.add(uniqueID);
        styleEl.id = 'pseudo-element-inhibitor';
        styleEl.textContent = `
          .${uniqueID}::before {
            content: none !important;
          }

          .${uniqueID}::after {
            content: none !important;
          }
        `;
        document.body.append(styleEl);
      }
    </script>
  </body>
</html>
