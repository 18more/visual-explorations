<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>
      187 - infer generated content pseudo-element box position in viewport
    </title>
    <!-- PEDAC

      Objective
      =========
      Determine the viewport position of a border box generated by a generated content pseudo-element.
      In other words, Element.getBoundingClientRect for pseudo-elements.

      UNDERSTANDING THE PROBLEM
      =========================

      - The only thing about pseudo-elements exposed in DOM APIs is their computed styles.
      - this gives us a width and a height
      - but no position

      Hypothesis #1
      - use an Element with the exact same styles at the exact same position in the DOM tree, and read the position of that element
      - not sure if having an element like that wouldn’t affect selector matching, though
      - it would, actually, for exaple with div:nth-child(4)

      Hypothesis #2
      - still replace the pseudo-element with an Element
      - to avoid mismatched CSS selectors, store the computed styles
        of every relevant element, do the replacement, then use those computed
        styles instead of cascading styles
      - a relevant element is any element whose layout styles might change
        when the pseudo-element is replaced with a real Element
      - a change in the tree structure can only affect selector matching among
        the children of the element from which the pseudo-element originates

      Problems with copying used values
      - when you back up the declarations from getComputedStyle and the element
        does generate a box and thus is laid out, then the resolved values
        for layout-depended properties like width will be the used values
      - this means that the initial layout was done on a computed value of
        width: auto, and maybe something like flex-basis: content
      - but when we apply our backed up styles, we may then apply used values
        like width: 190px !important, and that will lead to a different layout
        than the original width: auto layout
      - to get the exact same layout, you’d need to apply the exact same styles
      - the spec for getComputedStyle says the resolved value will be the
        actual computed value if the resolved value of the display property
        is none
      - I’m not sure if it would work correctly, or what would be the impact
        on performance if I set all of the affected elements to display: none
        before backing up their computed styles...
        https://drafts.csswg.org/cssom/#resolved-value
      - even if you grab computed values, the display property value affects
        the values of other properties, which can affect the layout
        - for example, a child of an ancestor with display: none seems to have
          a resolved display: none, too
        - thus, it doesn’t participate in a formatting context it would be
          in if display was not none
        - specifically, min-width will compute to 0px or auto depending on the
          formatting context
        - "It also resolves to zero when no box is generated."
          https://drafts.csswg.org/css-sizing/#valdef-width-auto


      EXAMPLES / TEST CASES
      =====================


      DATA STRUCTURES
      ===============


      ALGORITHM
      =========


      CODE WITH INTENT
      ================

    -->
    <style>
      :root {
        /* display: none; */
      }

      * {
        border: 1px dashed black;
      }

      body {
        display: flex;
        /* color: red; */
      }

      body::before {
        content: 'body::before';
        font-size: 3em;
      }

      body > *:nth-child(4) {
        background-color: tomato;
      }

      h1::before {
        content: 'H1' !important;
      }

      /* ::after {
        content: '::after';
      } */

      .fake-after {
        font-size: 3em;
      }
    </style>
  </head>
  <body>
    <h1>Text inside an h1 element</h1>
    <p>Text inside a p element</p>
    Text inside a text run
    <!-- <span class="fake-after"
      >Text inside an anonymous inline box inside a box generated by the ::after
      pseudo-element.</span
    > -->
    <script>
      function getRandomInt(max) {
        return Math.floor(Math.random() * max);
      }

      function copyDeclarationBlock(declarationBlock) {
        const result = {};
        for (let i = 0; i < declarationBlock.length; i += 1) {
          const propName = declarationBlock.item(i);
          const propValue = declarationBlock.getPropertyValue(propName);
          result[propName] = propValue;
        }

        return result;
      }

      function recursivelyBackupStyles(el) {
        for (let i = 0; i < el.children.length; i += 1) {
          const childEl = el.children[i];
          recursivelyBackupStyles(childEl);
        }

        const backupStyles = {
          id: String(getRandomInt(100000)),
          before: copyDeclarationBlock(getComputedStyle(el, '::before')),
          own: copyDeclarationBlock(getComputedStyle(el)),
          after: copyDeclarationBlock(getComputedStyle(el, '::after')),
        };

        el.backupStyles = backupStyles;
        el.setAttribute('data-id', backupStyles.id);
      }

      function recursivelyApplyBackupStyles(el) {
        const rulesString = recursivelyBuildBackupStylesString(el);
        const styleEl = document.createElement('style');
        styleEl.textContent = rulesString;
        document.body.append(styleEl);
      }

      function recursivelyBuildBackupStylesString(el) {
        const styleEl = document.createElement('style');
        const elRulesString = buildBackupStylesRulesString(el);
        const childElRulesStrings = [];
        for (let i = 0; i < el.children.length; i += 1) {
          const childEl = el.children[i];
          childElRulesStrings.push(recursivelyBuildBackupStylesString(childEl));
        }

        return [elRulesString, childElRulesStrings.join('\n')].join('\n');
      }

      function buildDeclarationString(backupStyles) {
        return Object.entries(backupStyles)
          .map(([name, value]) => `${name}: ${value} !important;`)
          .join('\n');
      }

      function buildBackupStylesRulesString(el) {
        const id = el.backupStyles.id;
        const declarationStrings = {
          before: buildDeclarationString(el.backupStyles.before),
          own: buildDeclarationString(el.backupStyles.own),
          after: buildDeclarationString(el.backupStyles.after),
        };
        const rulesString = `
          [data-id="${id}"]::before {
            ${declarationStrings.before}
          }

          [data-id="${id}"] {
            ${declarationStrings.own}
          }

          [data-id="${id}"]::after {
            ${declarationStrings.after}
          }
        `;

        return rulesString;
      }

      function replacePseudo(el) {
        console.log('replace called');
        recursivelyBackupStyles(el);
        // recursivelyApplyBackupStyles(el);
        disablePseudoBefore(el);
        const divEl = document.createElement('div');
      }

      function disablePseudoBefore(el) {
        const uniqueID = 'some-unique-id';
        el.classList.add(uniqueID);
        const styleEl = document.createElement('style');
        styleEl.textContent = `
          .${uniqueID}::before {
            content: none !important;
          }
        `;
        document.body.append(styleEl);
      }
    </script>
    <!-- <style>
      body::before {
        content: '::before inside style at the end of body';
        font-size: 3em;
      }
    </style> -->
  </body>
</html>
